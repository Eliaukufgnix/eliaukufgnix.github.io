<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据库 | Eliaukufgnix</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="我的个人博客">
    
    <link rel="preload" href="/assets/css/0.styles.5ab8ebd7.css" as="style"><link rel="preload" href="/assets/js/app.3e89323d.js" as="script"><link rel="preload" href="/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/assets/js/11.136159a4.js" as="script"><link rel="prefetch" href="/assets/js/10.4e92518d.js"><link rel="prefetch" href="/assets/js/12.04d8f4fb.js"><link rel="prefetch" href="/assets/js/13.3911ca0f.js"><link rel="prefetch" href="/assets/js/3.7c0fc0d6.js"><link rel="prefetch" href="/assets/js/4.fc333d27.js"><link rel="prefetch" href="/assets/js/5.bfef3080.js"><link rel="prefetch" href="/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/assets/js/7.9c9172a7.js"><link rel="prefetch" href="/assets/js/8.64f5a877.js"><link rel="prefetch" href="/assets/js/9.c6ac0550.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5ab8ebd7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Eliaukufgnix</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/前端笔记.html" class="nav-link">
  个人笔记
</a></div><div class="nav-item"><a href="/suanfa/算法.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/Eliaukufgnix" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/前端笔记.html" class="nav-link">
  个人笔记
</a></div><div class="nav-item"><a href="/suanfa/算法.html" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/Eliaukufgnix" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>后端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/数据库.html" class="active sidebar-link">数据库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据库.html#关系型数据库" class="sidebar-link">关系型数据库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据库.html#基础语句" class="sidebar-link">基础语句</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#sql-server时间数据类型" class="sidebar-link">SQL Server时间数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#分页查询" class="sidebar-link">分页查询</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#三大范式" class="sidebar-link">三大范式</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#存储过程" class="sidebar-link">存储过程</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#sql注入式攻击" class="sidebar-link">SQL注入式攻击</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#触发器" class="sidebar-link">触发器</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#游标" class="sidebar-link">游标</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#锁" class="sidebar-link">锁</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#视图" class="sidebar-link">视图</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#索引" class="sidebar-link">索引</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#sql临时表" class="sidebar-link">SQL临时表</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#sql语句的优化问题" class="sidebar-link">SQL语句的优化问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#如何处理海量数据" class="sidebar-link">如何处理海量数据</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#非关系型数据库" class="sidebar-link">非关系型数据库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据库.html#认识redis" class="sidebar-link">认识Redis</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#数据类型" class="sidebar-link">数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis全局命令" class="sidebar-link">Redis全局命令</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis安全性" class="sidebar-link">Redis安全性</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis的作用-重点理解" class="sidebar-link">Redis的作用[重点理解]</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis事务-拓展" class="sidebar-link">Redis事务[拓展]</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis持久化机制-拓展" class="sidebar-link">Redis持久化机制[拓展]</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis内存淘汰机制-拓展" class="sidebar-link">Redis内存淘汰机制[拓展]</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#过期key处理-拓展" class="sidebar-link">过期Key处理[拓展]</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#redis编程" class="sidebar-link">Redis编程</a></li><li class="sidebar-sub-header"><a href="/blog/数据库.html#demo" class="sidebar-link">Demo</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据库"><a href="#数据库" class="header-anchor">#</a> 数据库</h1> <h2 id="关系型数据库"><a href="#关系型数据库" class="header-anchor">#</a> 关系型数据库</h2> <h3 id="基础语句"><a href="#基础语句" class="header-anchor">#</a> 基础语句</h3> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- sql语法规范:所有关键字大写的  用户自定义的根据用户实际情况来 但是数据库不区分大小写</span>

<span class="token comment">-- 四大基本语句</span>
<span class="token comment">-- 查询</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> studentinfo
<span class="token comment">-- 添加</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> Studentinfo<span class="token punctuation">(</span>name<span class="token punctuation">,</span>phone<span class="token punctuation">,</span>create_time<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'王五'</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">'2023-03-13 13:00:00'</span><span class="token punctuation">)</span>
<span class="token comment">-- 特殊写法：约束性较强1）字段顺序必须和表的一样  2)所有字段都需要赋值</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> Studentinfo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token comment">-- 千万小心：在写更新语句和删除语句的时候一定要检查条件。</span>
<span class="token comment">-- 删除</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> Studentinfo <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">2</span>
<span class="token comment">-- 更新</span>
<span class="token keyword">update</span> Studentinfo <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">'王五'</span>  <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">3</span>


<span class="token comment">-- 条件查询   where</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Studentinfo <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">2</span>

<span class="token comment">-- 多个条件   and    or</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> ID<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">AND</span> Name<span class="token operator">=</span><span class="token string">'王明'</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> ID<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">OR</span> Name<span class="token operator">=</span><span class="token string">'王明111'</span>

<span class="token comment">-- top 查询</span>
<span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token comment">--mysql</span>

<span class="token comment">-- ORDER BY 排序   </span>
<span class="token comment">-- ASC   升序 从小到大</span>
<span class="token comment">-- DESC  降序 从大到小</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Name <span class="token keyword">DESC</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Name <span class="token keyword">ASC</span> 


<span class="token comment">-- 语句分为5个阶段</span>

结果集部分   表部分    条件部分       排序部分     分组部分


<span class="token comment">-- like 模糊匹配</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Name <span class="token operator">LIKE</span> <span class="token string">'王%'</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Name <span class="token operator">LIKE</span> <span class="token string">'%二'</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> Name <span class="token operator">LIKE</span> <span class="token string">'%王%'</span>

<span class="token comment">-- between and 范围检索 包含1和5</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> DistrictID <span class="token operator">Between</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">5</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> DistrictID<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">AND</span> DistrictID<span class="token operator">&lt;=</span><span class="token number">5</span>


<span class="token comment">-- in  和not in  存在包含</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Student <span class="token keyword">WHERE</span> DistrictID <span class="token operator">NOT</span> <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">-- CASE WHEN THEN END  多种值的一个判断</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">CASE</span>  Gendar <span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'女'</span> <span class="token keyword">WHEN</span> <span class="token number">0</span> <span class="token keyword">THEN</span> <span class="token string">'男'</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> GendarText  <span class="token keyword">FROM</span> Student 


<span class="token comment">-- 聚合函数</span>
<span class="token comment">-- 聚合函数只能查询单一字段，不能得到该条数据的完整数据</span>
sum  avg  max min
<span class="token keyword">SELECT</span> <span class="token function">sum</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student
<span class="token keyword">SELECT</span> <span class="token function">avg</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student
<span class="token keyword">SELECT</span> <span class="token function">min</span><span class="token punctuation">(</span>Id<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student

<span class="token comment">-- group by  分组语句  将数据分组然后进行统计</span>
<span class="token comment">-- 根据什么字段group by 那么你的select后面就只能有这个字段，聚合函数可以出现在group by 的select后面</span>
<span class="token keyword">SELECT</span> Gendar<span class="token punctuation">,</span><span class="token function">MAX</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span> <span class="token keyword">from</span> Student <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Gendar 


<span class="token comment">-- 联合查询语句</span>
<span class="token comment">-- 1确定你主表Student  查学生   附带要地区名字</span>

<span class="token comment">-- 2确定关系两表之间的关系  Student（DistrictID）    S_Distrcit(Distrcit_ID)</span>

<span class="token comment">-- 3确定你要的字段   Id Name Phone DistrictName</span>
<span class="token keyword">SELECT</span>  s<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span>DistrictName  
<span class="token keyword">FROM</span>  Student s <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> S_District  d
<span class="token keyword">ON</span> s<span class="token punctuation">.</span>DistrictID<span class="token operator">=</span>d<span class="token punctuation">.</span>DistrictID

<span class="token comment">-- INNER JOIN：要求数据必须能够关联起来，如果不能关联则数据不会被显示出来</span>
<span class="token keyword">SELECT</span> s<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>c<span class="token punctuation">.</span>class_name <span class="token keyword">FROM</span> Student <span class="token keyword">as</span> s <span class="token keyword">inner</span> <span class="token keyword">join</span> Classes  c <span class="token keyword">on</span> c<span class="token punctuation">.</span>id<span class="token operator">=</span>s<span class="token punctuation">.</span>ClassID
<span class="token comment">-- LEFT JOIN：以左侧表为主表，主表中有多少条数据就显示多少条数据，能关联则显示关联信息，不能关联则显示为NULL</span>
<span class="token keyword">SELECT</span> s<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>c<span class="token punctuation">.</span>class_name <span class="token keyword">FROM</span> Student <span class="token keyword">as</span> s <span class="token keyword">left</span> <span class="token keyword">join</span> Classes  c <span class="token keyword">on</span> c<span class="token punctuation">.</span>id<span class="token operator">=</span>s<span class="token punctuation">.</span>ClassID
<span class="token comment">-- RIGHT JOIN</span>
<span class="token keyword">SELECT</span> s<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>c<span class="token punctuation">.</span>class_name <span class="token keyword">FROM</span>  Classes  c <span class="token keyword">right</span> <span class="token keyword">join</span> Student <span class="token keyword">as</span> s <span class="token keyword">on</span> c<span class="token punctuation">.</span>id<span class="token operator">=</span>s<span class="token punctuation">.</span>ClassID

<span class="token comment">-- UNION 合并  注意:合并的时候两个类数据类型必须相同，相同内容会自动合并</span>
<span class="token keyword">SELECT</span> Name<span class="token punctuation">,</span>ID <span class="token keyword">FROM</span> Student
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> class_name<span class="token punctuation">,</span>id <span class="token keyword">FROM</span> Classes

<span class="token comment">-- UNION ALL 区别：相同内容也不合并</span>
<span class="token keyword">SELECT</span> Name <span class="token keyword">FROM</span> Student
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> class_name <span class="token keyword">FROM</span> Classes
</code></pre></div><h3 id="sql-server时间数据类型"><a href="#sql-server时间数据类型" class="header-anchor">#</a> SQL Server时间数据类型</h3> <table><thead><tr><th>数据类型</th> <th>描述</th> <th>样式</th> <th>存储</th></tr></thead> <tbody><tr><td>date</td> <td>仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。</td> <td>2020-04-15</td> <td>3 bytes</td></tr> <tr><td>time</td> <td>仅存储时间。精度为 100 纳秒。</td> <td>13:23:22.5333333</td> <td>3-5 bytes</td></tr> <tr><td>datetime</td> <td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 精度为 3.33 毫秒。</td> <td>2020-04-15 13:24:16.920</td> <td>8 bytes</td></tr> <tr><td>datetime2</td> <td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 精度为 100 纳秒。（ datetime的升级版 ）</td> <td>2020-04-15 13:26:07.8100000</td> <td>6-8 bytes</td></tr> <tr><td>smalldatetime</td> <td>从 1900 年 1 月 1 日 到 2079 年 6 月 6 日 精度为 1 分钟。</td> <td>2020-04-15 13:27:00</td> <td>4 bytes</td></tr> <tr><td>datetimeoffset</td> <td>与 datetime2 相同 外加时区偏移。</td> <td>2020-04-15 13:28:01.3133333 +00:00</td> <td>8-10 bytes</td></tr> <tr><td>timestamp</td> <td>存储唯一的数字，每当创建或修改某行时，该数字会更新。 timestamp 基于内部时钟，不对应真实时间。 每个表只能有一个 timestamp 变量。（ 时间戳 ）</td> <td>0x0000000000000FA0</td> <td></td></tr></tbody></table> <h3 id="分页查询"><a href="#分页查询" class="header-anchor">#</a> 分页查询</h3> <p>1、方式一：使用NOT IN子查询</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">from</span> S_Province
<span class="token keyword">where</span> ProvinceID <span class="token operator">not</span> <span class="token operator">in</span> 
 <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">TOP</span> <span class="token number">10</span> ProvinceID <span class="token keyword">from</span> S_Province <span class="token keyword">order</span> <span class="token keyword">by</span> ProvinceID <span class="token keyword">asc</span><span class="token punctuation">)</span> 
<span class="token keyword">order</span> <span class="token keyword">by</span> ProvinceID
</code></pre></div><p>**2、方式二：**ROW_NUMBER() OVER(ORDER BY )</p> <p>初始版：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 分页查询公式-row_number()</span>
<span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token variable">@pageSize</span> <span class="token operator">*</span> 
<span class="token keyword">from</span> <span class="token punctuation">(</span>
 <span class="token comment">-- rownumber是别名，可按自己习惯取</span>
 <span class="token keyword">select</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> 主键 <span class="token keyword">asc</span><span class="token punctuation">)</span> <span class="token keyword">as</span> rownumber<span class="token punctuation">,</span><span class="token operator">*</span> 
 <span class="token keyword">from</span> 表名<span class="token punctuation">)</span> temp_row
<span class="token keyword">where</span> rownumber<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">@pageIndex</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token variable">@pageSize</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>例子：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">10</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> 
 <span class="token punctuation">(</span><span class="token keyword">SELECT</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ProvinceID<span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">Row</span><span class="token punctuation">,</span><span class="token operator">*</span> <span class="token keyword">FROM</span> S_Province<span class="token punctuation">)</span> <span class="token keyword">AS</span> t 
<span class="token keyword">WHERE</span> t<span class="token punctuation">.</span>ProvinceID<span class="token operator">&gt;</span><span class="token number">30</span>
</code></pre></div><p>上述例子中的子查询语句会查询全表，效率较低，可以对子查询内容进行优化。</p> <p>优化版：<strong>推荐使用该方式</strong>，效率较高</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 分页查询公式-row_number()-优化版本</span>
<span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span> <span class="token punctuation">(</span>
 <span class="token comment">-- rownumber是别名，可按自己习惯取</span>
 <span class="token keyword">select</span> <span class="token keyword">top</span> <span class="token punctuation">(</span><span class="token variable">@pageIndex</span><span class="token operator">*</span><span class="token variable">@pageSize</span><span class="token punctuation">)</span> row_number<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">over</span><span class="token punctuation">(</span><span class="token keyword">order</span> <span class="token keyword">by</span> 主键 <span class="token keyword">asc</span><span class="token punctuation">)</span> 
 <span class="token keyword">as</span> rownumber<span class="token punctuation">,</span><span class="token operator">*</span> 
 <span class="token keyword">from</span> 表名<span class="token punctuation">)</span> temp_row
<span class="token keyword">where</span> rownumber<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">@pageIndex</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token variable">@pageSize</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>3、方式三：<strong>只有SQL Server2012之后的版本才能使用</strong></p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 分页查询公式-offset /fetch next</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表名
<span class="token keyword">order</span> <span class="token keyword">by</span> 主键 或 其他索引列 
<span class="token comment">-- @pageIndex：页码、@pageSize：每页记录数</span>
<span class="token keyword">offset</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">@pageIndex</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token variable">@pageSize</span><span class="token punctuation">)</span> <span class="token keyword">rows</span>
<span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token variable">@pageSize</span> <span class="token keyword">rows</span> only<span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 分页查询第2页，每页有10条记录</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> S_Province
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ProvinceID
<span class="token keyword">OFFSET</span> <span class="token number">10</span> <span class="token keyword">ROWS</span> 
<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token number">10</span> <span class="token keyword">ROWS</span> ONLY
</code></pre></div><h3 id="三大范式"><a href="#三大范式" class="header-anchor">#</a> 三大范式</h3> <p>第一范式(1NF)：属性不可分割，即每个属性都是不可分割的原子项。(实体的属性即表中的列)</p> <p>第二范式(2NF)：满足第一范式；且不存在部分依赖，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)</p> <p>第三范式(3NF)：满足第二范式；且不存在传递依赖，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。</p> <h3 id="存储过程"><a href="#存储过程" class="header-anchor">#</a> 存储过程</h3> <p>介绍</p> <p>数据库中内置的程序段，当运行时，将程序段中的SQL语句依次执行。相当于程序中的函数，关键字procedure 可省略写为proc</p> <p>作用：存储过程内部可以进行业务逻辑运算</p> <p>优点：</p> <p>1.相对于SQL语句，存储过程更安全（体现在存储过程参数传递上）</p> <p>2.更高效，存储过程只需要创建时编译，后续执行无需频繁编译。</p> <p>缺点：</p> <p>1麻烦</p> <p>2不便于管理</p> <h4 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h4> <p>1、创建存储过程</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">procedure</span> 名称
@参数<span class="token number">1</span>名 参数类型，@参数<span class="token number">2</span>名 参数类型
<span class="token keyword">as</span>
 存储过程执行的内容
go
</code></pre></div><p>2、修改存储过程</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">procedure</span> 名称
@参数<span class="token number">1</span>名 参数类型，@参数<span class="token number">2</span>名 参数类型
<span class="token keyword">as</span>
 存储过程执行的内容
go
</code></pre></div><p>3、使用存储过程，关键字execute，可省略写为exec</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">execute</span> 名称 参数<span class="token number">1</span>，参数<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p><strong>带返回值的存储过程，两种返回值方式</strong></p> <h4 id="return"><a href="#return" class="header-anchor">#</a> return</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">proc</span> 名称
@变量名<span class="token number">1</span> 数据类型<span class="token punctuation">,</span>
@变量名<span class="token number">2</span> 数据类型<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">as</span>
 存储过程执行的内容
go
</code></pre></div><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- return类型返回值</span>
<span class="token comment">-- 特点：1只能返回一个结果  2只能返回数字结果</span>
<span class="token keyword">alter</span> <span class="token keyword">proc</span> pr_insert_studentInfo_return
<span class="token variable">@s_name</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@s_birth</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@s_sex</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">as</span>
 <span class="token keyword">insert</span> <span class="token keyword">into</span> StudentInfo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token variable">@s_name</span><span class="token punctuation">,</span><span class="token variable">@s_birth</span><span class="token punctuation">,</span><span class="token variable">@s_sex</span><span class="token punctuation">)</span>
 <span class="token keyword">return</span> <span class="token string">'132'</span>
go

<span class="token comment">-- 声明变量</span>
<span class="token keyword">declare</span> <span class="token variable">@return_value</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
<span class="token keyword">exec</span> <span class="token variable">@return_value</span><span class="token operator">=</span> pr_insert_studentInfo_return <span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span>
<span class="token keyword">select</span> <span class="token variable">@return_value</span>
</code></pre></div><h4 id="output"><a href="#output" class="header-anchor">#</a> output</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--output返回类型</span>
<span class="token comment">--特点：1返回类型不确定 2返回个数不限制</span>
<span class="token keyword">create</span> <span class="token keyword">proc</span> pr_insert_studentInfo_output
<span class="token variable">@s_name</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@s_birth</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@s_sex</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@newid</span> <span class="token keyword">int</span> output<span class="token punctuation">,</span><span class="token comment">--约定该参数为output类型参数</span>
<span class="token variable">@new_name</span> nvarchar<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> output
<span class="token keyword">as</span>
 <span class="token keyword">insert</span> <span class="token keyword">into</span> StudentInfo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token variable">@s_name</span><span class="token punctuation">,</span><span class="token variable">@s_birth</span><span class="token punctuation">,</span><span class="token variable">@s_sex</span><span class="token punctuation">)</span>
 <span class="token keyword">set</span> <span class="token variable">@newid</span><span class="token operator">=</span>@<span class="token variable">@identity</span> <span class="token comment">--全局变量，获取本次插入数据的主键</span>
 <span class="token keyword">set</span> <span class="token variable">@new_name</span><span class="token operator">=</span><span class="token variable">@s_name</span> 
go

<span class="token keyword">declare</span> <span class="token variable">@newid</span> <span class="token keyword">int</span>
<span class="token keyword">declare</span> <span class="token variable">@new_name</span> nvarchar<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
<span class="token keyword">exec</span> pr_insert_studentInfo_output <span class="token string">'admin'</span><span class="token punctuation">,</span><span class="token string">'1999-01-01'</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">,</span><span class="token variable">@newid</span> output<span class="token punctuation">,</span><span class="token variable">@new_name</span> output
<span class="token keyword">select</span> <span class="token variable">@newid</span><span class="token punctuation">,</span><span class="token variable">@new_name</span>
</code></pre></div><p>return 和 output
return编写上比较简单，output比较灵活。</p> <h4 id="net对于存储过程的调用"><a href="#net对于存储过程的调用" class="header-anchor">#</a> .NET对于存储过程的调用</h4> <p>1、存储过程的写操作</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">//</span>
<span class="token class-name"><span class="token keyword">int</span></span> id <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token comment">//pr_delete_StudentInfo_by_id</span>
<span class="token comment">//存储过程调用还是由ado.net和jdbc操作</span>
<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">SqlConnection</span> connection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlConnection</span><span class="token punctuation">(</span>ConfigHelper<span class="token punctuation">.</span><span class="token function">GetConnectionString</span><span class="token punctuation">(</span><span class="token string">&quot;sqlserver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//删除  写操作</span>
    <span class="token class-name">SqlCommand</span> sqlCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlCommand</span><span class="token punctuation">(</span><span class="token string">&quot;pr_delete_StudentInfo_by_id&quot;</span><span class="token punctuation">,</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//为ado指定操作方式为存储过程方式</span>
    sqlCommand<span class="token punctuation">.</span>CommandType <span class="token operator">=</span> CommandType<span class="token punctuation">.</span>StoredProcedure<span class="token punctuation">;</span>
    <span class="token comment">//设置param参数</span>
    sqlCommand<span class="token punctuation">.</span>Parameters<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">&quot;@s_id&quot;</span><span class="token punctuation">,</span> SqlDbType<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">.</span>Value<span class="token operator">=</span>id<span class="token punctuation">;</span>
    <span class="token comment">//执行存储过程</span>
    connection<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sqlCommand<span class="token punctuation">.</span><span class="token function">ExecuteNonQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    connection<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2、存储过程的读操作</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name">SqlConnection</span> connection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlConnection</span><span class="token punctuation">(</span>ConfigHelper<span class="token punctuation">.</span><span class="token function">GetConnectionString</span><span class="token punctuation">(</span><span class="token string">&quot;sqlserver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">// DataSet+DataAdapter</span>
        <span class="token class-name">SqlDataAdapter</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlDataAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个空适配器</span>
        <span class="token comment">// 存储过程所有处理都是有Command类处理的</span>
        <span class="token class-name">SqlCommand</span> sqlCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlCommand</span><span class="token punctuation">(</span><span class="token string">&quot;pr_query_StudentInfo&quot;</span><span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sqlCommand<span class="token punctuation">.</span>CommandType <span class="token operator">=</span> CommandType<span class="token punctuation">.</span>StoredProcedure<span class="token punctuation">;</span>
        <span class="token comment">// 适配器装载一个命令类对象(携带了一个查询的存储过程)</span>
        adapter<span class="token punctuation">.</span>SelectCommand <span class="token operator">=</span> sqlCommand<span class="token punctuation">;</span>
        <span class="token class-name">DataSet</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        adapter<span class="token punctuation">.</span><span class="token function">Fill</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">;</span>
        GridView1<span class="token punctuation">.</span>DataSource <span class="token operator">=</span> ds<span class="token punctuation">;</span>
        GridView1<span class="token punctuation">.</span><span class="token function">DataBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  

        <span class="token comment">// DataReader+Command</span>
        <span class="token class-name">SqlCommand</span> sqlCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SqlCommand</span><span class="token punctuation">(</span><span class="token string">&quot;pr_query_StudentInfo&quot;</span><span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sqlCommand<span class="token punctuation">.</span>CommandType <span class="token operator">=</span> CommandType<span class="token punctuation">.</span>StoredProcedure<span class="token punctuation">;</span>
        connection<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SqlDataReader</span> reader <span class="token operator">=</span> sqlCommand<span class="token punctuation">.</span><span class="token function">ExecuteReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Response<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>reader<span class="token punctuation">[</span><span class="token string">&quot;Name&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><h3 id="sql注入式攻击"><a href="#sql注入式攻击" class="header-anchor">#</a> SQL注入式攻击</h3> <p>概念：所谓SQL注入式攻击，就是输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令的输入参数，通过植入特殊的SQL命令实现注入攻击效果。</p> <p>常见的SQL注入式攻击过程类如：</p> <p>⑴ 某个<a href="https://baike.baidu.com/item/ASP.NET/197912" target="_blank" rel="noopener noreferrer">ASP.NET<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Web应用有一个登录页面，这个登录页面控制着用户是否有权访问应用，它要求用户输入一个名称和密码。</p> <p>⑵ 登录页面中输入的内容将直接用来构造动态的SQL命令，或者直接用作<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener noreferrer">存储过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的参数。下面是ASP.NET应用构造查询的一个例子：</p> <p>System.Text.StringBuilder query = new System.Text.StringBuilder(</p> <p>&quot;SELECT * from Users WHERE login = '&quot;)</p> <p>.<a href="https://baike.baidu.com/item/Append/8293363" target="_blank" rel="noopener noreferrer">Append<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>(txtLogin.Text).Append(&quot;' AND password='&quot;)</p> <p>.Append(txtPassword.Text).Append(&quot;'&quot;);</p> <p>⑶ 攻击者在用户名字和密码输入框中输入&quot;'或'1'='1&quot;之类的内容，例如a' or '1'='1。</p> <p>⑷ 用户输入的内容提交给服务器之后，服务器运行上面的<a href="https://baike.baidu.com/item/ASP.NET/197912" target="_blank" rel="noopener noreferrer">ASP.NET<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>代码构造出查询用户的SQL命令，但由于攻击者输入的内容非常特殊，所以最后得到的SQL命令变成：SELECT * from Users WHERE login = '' or '1'='1' AND password = '' or '1'='1'。</p> <p>⑸ 服务器执行查询或存储过程，将用户输入的身份信息和服务器中保存的身份信息进行对比。</p> <p>⑹ 由于SQL命令实际上已被注入式攻击修改，已经不能真正验证用户身份，所以系统会错误地授权给攻击者。</p> <p>如果攻击者知道应用会将<a href="https://baike.baidu.com/item/%E8%A1%A8%E5%8D%95" target="_blank" rel="noopener noreferrer">表单<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中输入的内容直接用于验证身份的查询，他就会尝试输入某些特殊的SQL字符串篡改查询改变其原来的功能，欺骗系统授予<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener noreferrer">访问<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>权限。</p> <h3 id="触发器"><a href="#触发器" class="header-anchor">#</a> 触发器</h3> <p>触发器是一种特殊的存储过程，它的运行是数据库自行进行调度的，当触发器的条件触发时，程序会自行调用。</p> <p><strong>触发器使用的两张临时表</strong></p> <p>添加临时表inserted：存放新数据</p> <p>删除临时表deleted：存放旧数据</p> <p><strong>语法</strong></p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">trigger</span> 名称
<span class="token keyword">on</span> 表明  <span class="token keyword">for</span>  操作名
<span class="token keyword">as</span>

go
</code></pre></div><h4 id="mssql检测数据执行命令"><a href="#mssql检测数据执行命令" class="header-anchor">#</a> MSSQL检测数据执行命令</h4> <p><strong>SET STATISTICS PROFILE ON</strong>：显示分析、编译和执行查询所需的时间（以毫秒为单位）。
<strong>SET STATISTICS IO ON</strong>：报告与语句内引用的每个表的扫描数、逻辑读取数（在高速缓存中访问的页数）和物理读取数（访问磁盘的次数）有关的信息。
<strong>SET STATISTICS TIME ON</strong>：显示每个查询执行后的结果集，代表查询执行的配置文件。</p> <p>通过设置可视化工具设置</p> <p><img src="https://img-blog.csdnimg.cn/20210522003526480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzkxNDk5,size_16,color_FFFFFF,t_70" alt="img"></p> <h3 id="游标"><a href="#游标" class="header-anchor">#</a> 游标</h3> <p>游标类似C语言中的指针，由于数据库是面向集合的，并不是面向对象，所以在进行进行逐行获取时存在天生的缺点。</p> <p>MSSQL数据库为了解决这一问题，在MSSQL中设置了游标的概念。</p> <p><strong>作用</strong></p> <p>游标可以将集合数据存入游标中，然后依次按位获取集合中的个体值。</p> <p><strong>缺点</strong></p> <p>游标将使数据库数据读取的效率大大降低，在不得已的情况下，尽量不要去使用。</p> <p>语法</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 针对某个结果集定义成一个游标</span>
<span class="token keyword">declare</span> 游标名 <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">-- 打开游标</span>
<span class="token keyword">open</span> 游标名
<span class="token comment">-- 定义一个变量让游标的值进行变化</span>
<span class="token keyword">declare</span> <span class="token variable">@current_aid</span> <span class="token keyword">int</span>
<span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token keyword">from</span> 游标名 <span class="token keyword">into</span> <span class="token variable">@current_aid</span><span class="token comment">--让游标下移 取出的值交给变量@current_aid</span>
 要执行的<span class="token keyword">sql</span>操作
<span class="token comment">-- @@fetch_status表示游标是否可以下移，如果为0则可继续</span>
<span class="token comment">-- 0 FETCH 语句成功</span>
<span class="token comment">-- -1 FETCH 语句失败或此行不在结果集中</span>
<span class="token comment">-- -2 被提取的行不存在</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>@<span class="token variable">@FETCH_STATUS</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">begin</span>
    <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token keyword">from</span> cursorArticleId <span class="token keyword">into</span> <span class="token variable">@current_aid</span>
    <span class="token keyword">update</span> <span class="token keyword">comment</span> <span class="token keyword">set</span> is_delete<span class="token operator">=</span><span class="token variable">@is_delete</span> <span class="token keyword">where</span> aid<span class="token operator">=</span><span class="token variable">@current_aid</span>
<span class="token keyword">end</span>
<span class="token comment">-- 关闭游标</span>
<span class="token keyword">close</span> 游标名
<span class="token comment">-- 释放游标</span>
<span class="token keyword">deallocate</span> 游标名
</code></pre></div><p>例子：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--游标 </span>
<span class="token comment">--删人  删文章</span>


<span class="token comment">--复杂的业务逻辑 proc</span>
<span class="token keyword">create</span> <span class="token keyword">proc</span> pr_updateUser_isdelete
<span class="token variable">@uid</span> <span class="token keyword">int</span><span class="token punctuation">,</span>
<span class="token variable">@is_delete</span> <span class="token keyword">int</span>
<span class="token keyword">as</span>
  <span class="token comment">--删除一个人的数据</span>
  <span class="token keyword">update</span> users <span class="token keyword">SET</span> is_delete<span class="token operator">=</span><span class="token variable">@is_delete</span> <span class="token keyword">where</span> uid<span class="token operator">=</span><span class="token variable">@uid</span>
 <span class="token comment">--删除一个人的所有文章</span>
 <span class="token keyword">update</span> article <span class="token keyword">SET</span> is_delete<span class="token operator">=</span><span class="token variable">@is_delete</span> <span class="token keyword">where</span> uid<span class="token operator">=</span><span class="token variable">@uid</span>
 
 <span class="token comment">--由于每一个文章都有多个评论，所以要遍历文章  拿到每一个文章的ID去删除他的评论</span>
 <span class="token keyword">declare</span> cursorArticleId <span class="token keyword">cursor</span>  <span class="token keyword">for</span> <span class="token keyword">select</span> aid <span class="token keyword">from</span> article <span class="token keyword">where</span> uid<span class="token operator">=</span><span class="token variable">@uid</span>
 <span class="token keyword">open</span> cursorArticleId 
 <span class="token keyword">declare</span> <span class="token variable">@current_aid</span> <span class="token keyword">int</span>
 <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token keyword">from</span> cursorArticleId <span class="token keyword">into</span> <span class="token variable">@current_aid</span><span class="token comment">--让游标下移 取出第一个文章id交给变量@current_aid</span>
 <span class="token comment">--更新评论</span>
 <span class="token keyword">update</span> <span class="token keyword">comment</span> <span class="token keyword">set</span> is_delete<span class="token operator">=</span><span class="token variable">@is_delete</span> <span class="token keyword">where</span> aid<span class="token operator">=</span><span class="token variable">@current_aid</span>
 <span class="token comment">-- @@fetch_status表示游标是否可以下移，如果为0则可继续</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>@<span class="token variable">@FETCH_STATUS</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
 <span class="token keyword">begin</span>
  <span class="token keyword">fetch</span> <span class="token keyword">next</span> <span class="token keyword">from</span> cursorArticleId <span class="token keyword">into</span> <span class="token variable">@current_aid</span>
  <span class="token keyword">update</span> <span class="token keyword">comment</span> <span class="token keyword">set</span> is_delete<span class="token operator">=</span><span class="token variable">@is_delete</span> <span class="token keyword">where</span> aid<span class="token operator">=</span><span class="token variable">@current_aid</span>
 <span class="token keyword">end</span>
 <span class="token keyword">close</span> cursorArticleId
 <span class="token keyword">deallocate</span> cursorArticleId
go


<span class="token keyword">exec</span> pr_updateUser_isdelete <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Users
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Article
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">Comment</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> Reply
</code></pre></div><h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>事务：事务中的语句如果要执行都执行，如果有一个不执行所有语句都不执行</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 创建事务</span>
<span class="token keyword">begin</span> <span class="token keyword">transaction</span>
<span class="token comment">-- 回滚</span>
<span class="token keyword">rollback</span> <span class="token comment">-- 各个表回到自己的原始状态</span>
<span class="token comment">-- 提交事务</span>
<span class="token keyword">commit</span> <span class="token keyword">transaction</span> 
</code></pre></div><p>例子：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--</span>
<span class="token comment">--一个操作里面有10条语句</span>


<span class="token comment">--业务场景：A银行  B银行</span>
<span class="token comment">--用户admin在两个行中分别开设了两个账号，admin从A银行进行金额转账 转到B银行</span>
<span class="token keyword">create</span> <span class="token keyword">proc</span> pr_zhuanzhang
<span class="token variable">@a_account</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token variable">@zmoney</span> <span class="token keyword">int</span>
<span class="token keyword">as</span>
   <span class="token keyword">declare</span> <span class="token variable">@ymoney</span> <span class="token keyword">int</span>
   <span class="token keyword">select</span> <span class="token variable">@ymoney</span><span class="token operator">=</span>money <span class="token keyword">from</span> abank <span class="token keyword">where</span> Account<span class="token operator">=</span><span class="token variable">@a_account</span><span class="token comment">--查出余额</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">@zmoney</span><span class="token operator">&gt;</span><span class="token variable">@ymoney</span><span class="token punctuation">)</span>
    <span class="token keyword">begin</span>
     <span class="token keyword">print</span> <span class="token string">'余额不足'</span>
    <span class="token keyword">end</span>
   <span class="token keyword">else</span>
    <span class="token keyword">begin</span>
     <span class="token comment">--创建事务</span>
     <span class="token keyword">begin</span> <span class="token keyword">transaction</span>
     <span class="token keyword">begin</span>
      <span class="token comment">--先从a银行减掉</span>
      <span class="token keyword">update</span> abank <span class="token keyword">set</span> money<span class="token operator">=</span>money<span class="token operator">-</span><span class="token variable">@zmoney</span> <span class="token keyword">where</span> Account<span class="token operator">=</span><span class="token variable">@a_account</span>
      <span class="token comment">--把减掉的钱加到B银行</span>
      <span class="token keyword">update</span> bbank <span class="token keyword">set</span> money<span class="token operator">=</span>money<span class="token operator">+</span><span class="token variable">@zmoney</span> <span class="token keyword">where</span> Account<span class="token operator">=</span><span class="token variable">@a_account</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>@<span class="token variable">@ERROR</span><span class="token operator">&lt;&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token keyword">begin</span>
       <span class="token keyword">rollback</span> <span class="token comment">--各个表回到自己的原始状态</span>
       <span class="token keyword">end</span>
      <span class="token keyword">else</span>
       <span class="token keyword">begin</span>
       <span class="token keyword">commit</span> <span class="token keyword">transaction</span> <span class="token comment">--提交</span>
       <span class="token keyword">end</span>
     <span class="token keyword">end</span>
    <span class="token keyword">end</span>
go

  
<span class="token keyword">exec</span> pr_zhuanzhang <span class="token string">'admin'</span><span class="token punctuation">,</span><span class="token number">500</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> abank  
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> bbank
</code></pre></div><h4 id="自动提交事务"><a href="#自动提交事务" class="header-anchor">#</a> 自动提交事务</h4> <p>每条单独的语句都是一个事务。</p> <p>在自动提交模式下， 每个数据库操作是在执行时已提交的事务。 此模式适合用于包含单个 SQL 语句的许多实际的事务。 不需要分隔，或者指定的这些事务完成。 在数据库中不支持事务的情况下，自动提交模式是唯一支持的模式。 在此类数据库语句仅在提交后可以执行它们并没有方法回滚它们;它们因此始终处于自动提交模式。</p> <p>自动提交事务为默认设置，无需额外进行设置。</p> <h4 id="隐式事务"><a href="#隐式事务" class="header-anchor">#</a> 隐式事务</h4> <p>隐式事务通过设置SET IMPLICIT_TRANSACTIONS ON 语句，将隐性事务模式设置为打开。</p> <p>一旦隐式事务打开，数据库实例第一次执行alert table，insert，create，open，delete，revoke，drop，select，fetch，truncate table，grant，update语句时，会自动开启一个事务，开启的事务需要利用commit或rollback结束；</p> <p>当事务结束时，一旦运行以上类型的语句，会再次自动开启一个新的事务，这样就形成了一个事务链。</p> <p>例子：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 开启隐式事务</span>
<span class="token keyword">SET</span> IMPLICIT_TRANSACTIONS <span class="token keyword">ON</span> 
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">[</span>dbo<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>ORDERINFO<span class="token punctuation">]</span> <span class="token punctuation">(</span>CUSTOMID<span class="token punctuation">,</span>PRODUCTID<span class="token punctuation">,</span>ORDERQUANTITY<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">21110</span><span class="token punctuation">,</span><span class="token string">'20'</span><span class="token punctuation">)</span>  
GO
<span class="token keyword">UPDATE</span> ORDERINFO <span class="token keyword">SET</span> PRODUCTID<span class="token operator">=</span><span class="token number">220000</span> <span class="token keyword">WHERE</span> CUSTOMID<span class="token operator">=</span><span class="token number">16</span>
GO
<span class="token comment">-- 事务结束，进行提交</span>
<span class="token keyword">COMMIT</span>
<span class="token comment">-- 关闭隐式事务</span>
<span class="token keyword">SET</span> IMPLICIT_TRANSACTIONS <span class="token keyword">OFF</span>
</code></pre></div><h4 id="显式事务"><a href="#显式事务" class="header-anchor">#</a> 显式事务</h4> <p>每个事务均以 BEGIN TRANSACTION 语句显式开始，以 COMMIT 或 ROLLBACK 语句显式结束。</p> <h4 id="事务特性"><a href="#事务特性" class="header-anchor">#</a> 事务特性</h4> <p>事务是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）属性，只有这样才能成为一个事务。</p> <h4 id="原子性"><a href="#原子性" class="header-anchor">#</a> 原子性</h4> <p>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。</p> <h4 id="一致性"><a href="#一致性" class="header-anchor">#</a> 一致性</h4> <p>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</p> <h4 id="隔离性"><a href="#隔离性" class="header-anchor">#</a> 隔离性</h4> <p>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。</p> <h4 id="持久性"><a href="#持久性" class="header-anchor">#</a> 持久性</h4> <p>事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。</p> <h4 id="事务隔离"><a href="#事务隔离" class="header-anchor">#</a> 事务隔离</h4> <p>隔离级别用于决定如何控制并发用户读写数据的操作。</p> <p>读操作默认使用共享锁；写操作需要使用排它锁。</p> <p>读操作能够控制它的处理的方式，写操作不能控制它的处理方式。</p> <h3 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h3> <h4 id="mssql锁的种类-锁的说明"><a href="#mssql锁的种类-锁的说明" class="header-anchor">#</a> MSSQL锁的种类/锁的说明</h4> <p>锁定数据库的一个表</p> <p>SELECT  *  FROM  table  WITH  (HOLDLOCK)
其他事务可以读取表，但不能更新删除</p> <p>SELECT  *  FROM  table  WITH  (TABLOCKX)
其他事务不能读取表,更新和删除</p> <p>SELECT  语句中“加锁选项”的功能说明
SQL  Server提供了强大而完备的锁机制来帮助实现数据库系统的并发性和高性能。用户既能使用SQL  Server的缺省设置也可以在select  语句中使用“加锁选项”来实现预期的效果。  本文介绍了SELECT语句中的各项“加锁选项”以及相应的功能说明。
功能说明：　
NOLOCK（不加锁）
此选项被选中时，SQL  Server  在读取或修改数据时不加任何锁。  在这种情况下，用户有可能读取到未完成事务（Uncommited  Transaction）或回滚(Roll  Back)中的数据,  即所谓的“脏数据”。</p> <p>HOLDLOCK（保持锁）
此选项被选中时，SQL  Server  会将此共享锁保持至整个事务结束，而不会在途中释放。</p> <p>UPDLOCK（修改锁）
此选项被选中时，SQL  Server  在读取数据时使用修改锁来代替共享锁，并将此锁保持至整个事务或命令结束。使用此选项能够保证多个进程能同时读取数据但只有该进程能修改数据。</p> <p>TABLOCK（表锁）
此选项被选中时，SQL  Server  将在整个表上置共享锁直至该命令结束。  这个选项保证其他进程只能读取而不能修改数据。</p> <p>PAGLOCK（页锁）
此选项为默认选项，  当被选中时，SQL  Server  使用共享页锁。</p> <p>TABLOCKX（排它表锁）
此选项被选中时，SQL  Server  将在整个表上置排它锁直至该命令或事务结束。这将防止其他进程读取或修改表中的数据。</p> <h4 id="并发产生的问题-锁定"><a href="#并发产生的问题-锁定" class="header-anchor">#</a> 并发产生的问题——锁定</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--数据连接1</span>

<span class="token keyword">begin</span> <span class="token keyword">tran</span> 
<span class="token keyword">update</span> books <span class="token keyword">set</span> bookname<span class="token operator">=</span><span class="token string">'C#'</span>
  <span class="token keyword">waitfor</span> delay <span class="token string">'0:0:5'</span>  
   <span class="token keyword">update</span> student <span class="token keyword">set</span> num<span class="token operator">=</span><span class="token string">'事务1'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">commit</span> <span class="token keyword">tran</span>

<span class="token comment">--数据连接2</span>

<span class="token keyword">begin</span> <span class="token keyword">tran</span> 
<span class="token keyword">update</span> student <span class="token keyword">set</span> num<span class="token operator">=</span><span class="token string">'事务1'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span>

  <span class="token keyword">waitfor</span> delay <span class="token string">'0:0:5'</span>  
   <span class="token keyword">update</span> books <span class="token keyword">set</span> bookname<span class="token operator">=</span><span class="token string">'python'</span>
<span class="token keyword">commit</span> <span class="token keyword">tran</span>

</code></pre></div><p>在多用户都用事务同时访问同一个数据资源的情况下，就会造成以下几种数据错误。</p> <ul><li>更新丢失：多个用户同时对一个数据资源进行更新，必定会产生被覆盖的数据，造成数据读写异常。</li> <li>不可重复读：如果一个用户在一个事务中多次读取一条数据，而另外一个用户则同时更新啦这条数据，造成第一个用户多次读取数据不一致。</li> <li>脏读：第一个事务读取第二个事务正在更新的数据表，如果第二个事务还没有更新完成，那么第一个事务读取的数据将是一半为更新过的，一半还没更新过的数据，这样的数据毫无意义。</li> <li>幻读：第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作，然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。</li></ul> <p>然而锁定，就是为解决这些问题所生的，他的存在使得一个事务对他自己的数据块进行操作的时候，而另外一个事务则不能插足这些数据块。这就是所谓的锁定。</p> <h4 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h4> <h5 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="header-anchor">#</a> <strong>死锁的四个必要条件</strong></h5> <p>1、互斥条件：一个资源每次只能被一个进程使用；</p> <p>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</p> <p>3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；</p> <p>4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；</p> <p>第一个事务（称为A）：先更新a表 ---&gt;&gt;停顿5秒----&gt;&gt;更新b表</p> <p>第二个事务（称为B）：先更新b表---&gt;&gt;停顿5秒----&gt;&gt;更新a表</p> <p>先执行事务A----5秒之内---执行事务B，出现死锁现象。</p> <p>过程是这样子的：</p> <ol><li>A更新a表，请求a的排他锁，成功。</li> <li>B更新b表，请求b的排他锁，成功。</li> <li>5秒过后</li> <li>A更新b，请求b的排它锁，由于B占用着b的排它锁，等待。</li> <li>B更新a，请求a的排它锁，由于A占用着a的排它锁，等待。</li></ol> <p>这样相互等待对方释放资源，造成资源读写拥挤堵塞的情况，就被称为死锁现象，也叫做阻塞。</p> <p>然而数据库并没有出现无限等待的情况，是因为数据库搜索引擎会定期检测这种状况，一旦发现有情况，立马选择一个事务作为牺牲品。牺牲的事务，将会回滚数据。</p> <p>然而数据库并没有出现无限等待的情况，是因为数据库搜索引擎会定期检测这种状况，一旦发现有情况，立马选择一个事务作为牺牲品。</p> <p>哪个人会被退回来，作为牺牲品，这个我们是可以控制的。控制语法：</p> <div class="language- extra-class"><pre class="language-text"><code>set deadlock_priority  &lt;级别&gt;
</code></pre></div><p>死锁处理的优先级别为 low&lt;normal&lt;high，不指定的情况下默认为normal，牺牲品为随机。如果指定，牺牲品为级别低的。</p> <p>还可以使用数字来处理标识级别：-10到-5为low，-5为normal，-5到10为high。</p> <h5 id="减少死锁的发生-提高数据库性能"><a href="#减少死锁的发生-提高数据库性能" class="header-anchor">#</a> 减少死锁的发生，提高数据库性能</h5> <p>死锁耗时耗资源，然而在大型数据库中，高并发带来的死锁是不可避免的，所以我们只能让其变的更少。</p> <ol><li>按照同一顺序访问数据库资源，上述例子就不会发生死锁</li> <li>保持是事务的简短，尽量不要让一个事务处理过于复杂的读写操作。事务过于复杂，占用资源会增多，处理时间增长，容易与其它事务冲突，提升死锁概率。</li> <li>尽量不要在事务中要求用户响应，比如修改新增数据之后在完成整个事务的提交，这样延长事务占用资源的时间，也会提升死锁概率。</li> <li>尽量减少数据库的并发量。</li> <li>尽可能使用分区表，分区视图，把数据放置在不同的磁盘和文件组中，分散访问保存在不同分区的数据，减少因为表中放置锁而造成的其它事务长时间等待。</li> <li>避免占用时间很长并且关系表复杂的数据操作。</li> <li>使用较低的隔离级别，使用较低的隔离级别比使用较高的隔离级别持有共享锁的时间更短。这样就减少了锁争用。</li></ol> <h3 id="视图"><a href="#视图" class="header-anchor">#</a> 视图</h3> <p>数据库中数据查询后产生的结果集，用户读取显示数据使用。</p> <p>不允许对视图进行修改。</p> <h4 id="查询缓存清理"><a href="#查询缓存清理" class="header-anchor">#</a> 查询缓存清理</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token operator">-</span><span class="token number">1.</span> 将当前数据库的全部脏页写入磁盘。“脏页”是已输入缓存区高速缓存且已修改但尚未写入磁盘的数据页。
<span class="token comment">--  CHECKPOINT 可创建一个检查点，在该点保证全部脏页都已写入磁盘，从而在以后的恢复过程中节省时间。</span>
<span class="token keyword">CHECKPOINT</span>
<span class="token comment">--2. 若要从缓冲池中删除清除缓冲区，请首先使用 CHECKPOINT 生成一个冷缓存。这可以强制将当前数据库的全部脏页写入磁盘，然后清除缓冲区。</span>
<span class="token comment">--  完成此操作后，便可发出 DBCC DROPCLEANBUFFERS 命令来从缓冲池中删除所有缓冲区。</span>
<span class="token keyword">DBCC</span> DROPCLEANBUFFERS
<span class="token comment">--3. 释放过程缓存将导致系统重新编译某些语句（例如，即席 SQL 语句），而不重用缓存中的语句。</span>
<span class="token keyword">DBCC</span> FREEPROCCACHE
<span class="token comment">--4. 从所有缓存中释放所有未使用的缓存条目。SQL Server 2005 Database Engine 会事先在后台清理未使用的缓存条目，以使内存可用于当前条目。</span>
<span class="token comment">-- 但是，可以使用此命令从所有缓存中手动删除未使用的条目。</span>
<span class="token keyword">DBCC</span> FREESYSTEMCACHE <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span><span class="token punctuation">`</span></span><span class="token string">'ALL'</span><span class="token punctuation">`</span> <span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token comment">--5. 要接着执行你的查询,不然SQLServer会时刻的自动往缓存里读入最有可能需要的数据页.</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>CHECKPOINT;
DBCC DROPCLEANBUFFERS;
DBCC FREEPROCCACHE;
DBCC FREESYSTEMCACHE ('ALL');
SET STATISTICS TIME ON ;
--查询条件
SET STATISTICS TIME OFF;
</code></pre></div><h3 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h3> <p>索引相当于是数据库表的一种特殊的目录。SQLServer提供了两种索引：聚集索引和非聚集索引。</p> <p><strong>聚集索引</strong></p> <p>表示物理上的连续性。</p> <p>字典：</p> <p>资</p> <p>方法：1通过拼音首字母查询    A B C                    物理连续</p> <p>方法：2通过偏旁查找              贝字底偏旁           逻辑连续</p> <p><strong>非聚集索引</strong></p> <p>表示逻辑上的连续性。</p> <p>聚集索引和非聚集索引的应用场景<img src="https://img-blog.csdnimg.cn/20190318221423928.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjIzNjg4,size_16,color_FFFFFF,t_70" alt="img"></p> <p>比如：返回某一范围内的数据中的一项数据。比如：我们的一个表中有一个时间字段，恰好我们把聚合索引建立在了该字段上，这个时候我们查询2019年1月1日到2019年12月30日之间的全部数据时，这个速度将会是很快，因为我们的这个字典正文是通过日期来进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据就行；如果我们使用非聚集索引，那么还要查到2019年1月2号对应的页码，然后再根据页码来查询数据，那将是很耗时的。</p> <h4 id="关于索引的不正确理解"><a href="#关于索引的不正确理解" class="header-anchor">#</a> 关于索引的不正确理解</h4> <p>1主键就是聚集索引</p> <p>通常来说，我们会在每个表中建立一个id字段，用来区分每一条数据，而且通常来说会使用id自增长配置，每次自增为1。聚集索引最大的好处就是建立查询数据的一个区间，降低查询数据的总条数，避免全表查询。在实际应用中，因为id是自动生成的，程序员并不知道每条记录所对应的id，所以我们很难在实际应用中进行一个id号作为查询条件。这也让id号作为聚集索引成为了一种资源浪费。其次，让每个id号都有不同的字段作为聚集索引页不符合“在大范围数量个不同的值作为非聚集索引”规则。所以说，这种错误操作是针对于用户经常修改记录内容，特别是索引项的时候还会起到负作用，但是对于查询速度并没有多大的影响。</p> <p>一般来说，对于erp系统的首页都会显示每个用户为签收的文件或者会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的条件，但是如果您的系统已经建立了很长时间，并且数据量庞大，那么每个用户打开首页的时候都进行了一次全表扫描，这样做的意义不是很大，而且对于1月之前的文件信息，用户已经进行处理完成了。如果说还进行一个多余数据查询，只是增加了数据库的开销而已。所以说，我们完全可以让用户打开系统首页的时候，数据库仅仅查询了这个用户近3个月的未处理的文件就可以了。通过“时间日期”这个字段来限制表的扫描条数，提高查询速度。如果说我们所使用的办公自动化系统，已经存在了2年的时间，那么从理论上来讲，查询速度将是原来的8倍之上。</p> <p>2.【只要建立索引就可以提高查询速度】 DBA</p> <p>3.【把所有需要提高查询速度的字段都加进聚集索引，用于提高查询效率】</p> <h4 id="使用索引总结"><a href="#使用索引总结" class="header-anchor">#</a> 使用索引总结</h4> <p>关于索引的使用问题，如果使用不当，不仅不会提高检索效率，如果过多或不当的索引配置，会导致系统效率低下。因为用户在每张表汇总加入一个索引，那么数据库就要做更多的工作。过多的索引甚至会导致索引碎片效应。</p> <h3 id="sql临时表"><a href="#sql临时表" class="header-anchor">#</a> SQL临时表</h3> <p>临时表与永久表相似，但临时表存储在tempdb中，当不再使用时会自动删除。临时表有两种类型：本地和全局。它们在名称、可见性以及可用性上有区别。</p> <p>特点：</p> <ol><li>本地临时表：用户在创建表的时候添加了&quot;#&quot;前缀，其她点是根据数据库连接独立，只有创建本地临时表的数据库连接时才有权访问该表；</li> <li>不同的数据连接中，创建的本地临时表虽然名字相同，但是这些表不存在任何关系。</li> <li>真正的临时表利用了数据库临时空间，由数据库自动进行维护，因此节省了表空间。而且由于临时表一般利用虚拟内存，大大减少了硬盘的I/O次数，提高了系统效率。</li> <li>临时表在事务完毕或会话完毕数据自动清空，不必记得用完后删除。</li></ol> <h4 id="本地临时表"><a href="#本地临时表" class="header-anchor">#</a> 本地临时表</h4> <p>本地临时表名称以单个数字符号(#)打头；它们只对当前用户连接可见；当实例断开后删除。</p> <p>数据库连接A：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment">#temp</span>
{
    id <span class="token keyword">int</span><span class="token punctuation">,</span>
    name nvarchar<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">int</span>
}
<span class="token comment">//可见</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token comment">#temp</span>
</code></pre></div><h3 id="sql语句的优化问题"><a href="#sql语句的优化问题" class="header-anchor">#</a> SQL语句的优化问题</h3> <p>​    1.select * from table1 where name = “wangji” and tid &gt; 10000</p> <p>​    2.select * from table1 where tid &gt; 10000 and name = “wangji”</p> <p>​    对于上面两条语句，分析感觉是有区别的。因为对于第一条，先查询出name为wangji的数据，然后再从这批数据查询出tid大于10000；而第二条，先查询出tid大于10000，然后再从这批数据查询出name为wangji的。</p> <p>​    其实对于这种分析是错误的。因为对于数据库来说，判断sql语句的时候，会判断出where中查询的条件那个索引能够缩小表的扫描条数。也就是自动化判断优先级。</p> <p>那么说对于sql的编写，哪些会造成全表搜索呢？（以下错误示范）</p> <ol><li>使用模糊查询like ：name like “%际”</li> <li>使用or查询：name = “wangji” or age &gt; 22</li> <li>使用非操作符、函数引起的不满足扫描参数的：如：NOT、!=、&lt;、&gt;、!&lt;、!&gt;、NOT EXISTS、 NOT IN、NOT LIKE等，另外还有函数。例如：</li></ol> <p>​      Name like “%际”</p> <p>​       Abs &lt; 5000</p> <p>优化的注意：</p> <blockquote><ol><li>尽量避免IN的作用相当于OR‘’</li> <li>NOT也尽量避免</li> <li>Exists和in的执行效率一样，也尽量避免使用</li> <li>使用函数charindex()和上面使用通配符%的模糊查询Like执行效率一样</li> <li>Union并不绝对比or执行效率高</li> <li>需要查询多少字段内容就查询多少字段内容，避免使用*所有字段内容获取</li> <li>Count(*)执行效率不会比count(字段名)慢</li> <li>Order by按聚集索引字段排序效率是最高的</li> <li>Top是高效：TOP 子句用于规定要返回的记录的数目。 select top 10 percent * from record --加“top 10 percent”表示查询的是数据表中前10%的数据,若将10改为20,则查询的就是前20%的数据.</li> <li>尽量避免使用子查询 多去使用临时表</li></ol></blockquote> <h3 id="如何处理海量数据"><a href="#如何处理海量数据" class="header-anchor">#</a> 如何处理海量数据</h3> <p>海量数据1000W级别以上才算是海量数据</p> <p>更新  删除   查询</p> <p>一、SQL语句优化</p> <p>二、存储过程</p> <p>三、读写分离   主从同步，MSSQL MYSQL完整主从同步方案</p> <p>四、大量使用临时表提高检索效率</p> <p>五、使用缓存（WEB技术）</p> <p>六、分库分表   多数情况下通过时间进行的</p> <p>七、数据库集群</p> <h2 id="非关系型数据库"><a href="#非关系型数据库" class="header-anchor">#</a> 非关系型数据库</h2> <h3 id="认识redis"><a href="#认识redis" class="header-anchor">#</a> 认识Redis</h3> <p>文章简单介绍：<a href="https://mp.weixin.qq.com/s/uQBXEQnD8li5xbnazXHgOA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/uQBXEQnD8li5xbnazXHgOA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="nosql分类"><a href="#nosql分类" class="header-anchor">#</a> NoSQL分类</h4> <h4 id="什么是redis"><a href="#什么是redis" class="header-anchor">#</a> 什么是Redis</h4> <h5 id="redis简介"><a href="#redis简介" class="header-anchor">#</a> Redis简介</h5> <p>是以key-value形式存储,和传统的关系型数据库不一样.不一定遵循传统数据库的一些基本要求.(非关系型的,分布式的,开源的,水平可拓展的)</p> <p>优点:
<strong>对数据高并发读写</strong>(直接是内存中进行读写的)
对海量数据的高效率存储和访问
对数据的可拓展性和高可用性.
<strong>单线程操作</strong>,每个操作都是原子操作,没有并发相关问题(redis 6)</p> <p>缺点:
redis(ACID处理非常简单)
无法做太复杂的关系数据库模型</p> <p>redis在线入门 ： <a href="http://try.redis.io/" target="_blank" rel="noopener noreferrer">http://try.redis.io/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
redis 中文资料站： <a href="http://www.redis.cn/" target="_blank" rel="noopener noreferrer">http://www.redis.cn/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/redis/redis-tutorial.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>使用场景：</p> <p>1.高并发，缓存；借助其读写速度快。</p> <p>2.消息队列: 单线程  内存栈特点。</p> <h3 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h3> <h4 id="概况"><a href="#概况" class="header-anchor">#</a> 概况</h4> <p>Redis支持的存储数据类型有很多：</p> <p>常用：<strong>string</strong>（字符串），<strong>hash</strong>（哈希），<strong>list</strong>（列表），<strong>set</strong>（集合）及<strong>zset</strong>(sorted set：有序集合)</p> <p><strong>命令格式</strong></p> <p>类型命令    key       参数数据</p> <p>set           name    dafei</p> <p><strong>操作建议</strong></p> <p>Redis操作有点是key-value形式存储数据</p> <p>另外Redis中的key大部分为String类型，value值根据缓存数据结构可以选用：string，hash，list，set，zset等类型。</p> <p><strong>注意：下面讲的各种类型，表述的是缓存数据的value类型。</strong></p> <h4 id="string类型"><a href="#string类型" class="header-anchor">#</a> String类型</h4> <p>String类型包含多种类型的特殊类型，并且是二进制安全的，其值可以是数值，可以是字符串，也可以是二进制数据。</p> <p>在Redis内容数据存储结构：</p> <h5 id="常用的命令"><a href="#常用的命令" class="header-anchor">#</a> <strong>常用的命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>set key value</td> <td>将key-value缓存redis中</td> <td>set name dafei</td></tr> <tr><td>get key</td> <td>从redis中获取key对应value值</td> <td>get name</td></tr> <tr><td>incr key</td> <td>将key对应value值 + 1</td> <td>incr age</td></tr> <tr><td>decr key</td> <td>将key对应value值-1</td> <td>decr age</td></tr> <tr><td>setex key seconds value</td> <td>将key-value缓存到redis中，seconds 秒后失效</td> <td>setex  sex  10  man</td></tr> <tr><td>ttl key</td> <td>查看key存活时间</td> <td>ttl sex</td></tr> <tr><td>del  key</td> <td>从redis中删除key</td> <td>del name</td></tr> <tr><td>setnx key value</td> <td>如果key已经存，不做任何操作，如果key不存，直接添加</td> <td>setnx  name xiaofei</td></tr></tbody></table> <h5 id="非常用命令"><a href="#非常用命令" class="header-anchor">#</a> <strong>非常用命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>incrby key increment</td> <td>给key对应值加increment</td> <td>incrby age 10</td></tr> <tr><td>mset k1 v1 k2 v2....</td> <td>批量添加k1v1 k2v2 key value对</td> <td>mset name dafei age 18</td></tr> <tr><td>mget k1  k2....</td> <td>批量获取k1, k2的值</td> <td>mget name  age</td></tr> <tr><td>append key  value</td> <td>在key对应的value值中拼+value</td> <td>append name yes</td></tr> <tr><td>setrange key  offset  value</td> <td>修改key对应的value值,替换为指定value,冲offset索引位置开始</td> <td>setrange name 2   xx</td></tr></tbody></table> <h5 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h5> <p>1&gt;计数器</p> <p>如：视频播放数系统就是使用redis作为视频播放数计数的基础组件。</p> <p><strong>incr  viewnum 1</strong></p> <p>2&gt;共享session</p> <p>出于负载均衡的考虑，分布式服务会将用户信息的访问均衡到不同服务器上，用户刷新一次访问可能会需要重新登录，为避免这个问题可以用redis将用户session集中管理，  在这种模式下只要保证redis的高可用和扩展性的，每次获取用户更新或查询登录信息都直接从redis中集中获取。</p> <p><strong>user_login_info:uid----&gt;{&quot;id&quot;:1, &quot;name&quot;:&quot;dafei&quot;, &quot;age&quot;:18}</strong></p> <h4 id="hash类型"><a href="#hash类型" class="header-anchor">#</a> Hash类型</h4> <p>Hash类型是String类型的field和value的映射表，或者说是一个String集合。它特别适合存储对象，相比较而言，将一个对象存储在Hash类型里要比存储在String类型里占用更少的内存空间。</p> <h5 id="常用的命令-2"><a href="#常用的命令-2" class="header-anchor">#</a> 常用的命令</h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>hset key field  value</td> <td>将field  value对缓存到redis中hash中，键值为key</td> <td>hset user name dafei</td></tr> <tr><td>hget key field</td> <td>从key对应hash列表中获取field字段</td> <td>hget user  name</td></tr> <tr><td>hexists key  field</td> <td>判断key对应的hash列表是否存在 field字段</td> <td>hexists user age</td></tr> <tr><td>hdel key  field</td> <td>删除key对应hash列表中field字段</td> <td>hdel user age</td></tr> <tr><td>hincrby  key  field  increment</td> <td>给key对应hash列表中field字段 + increment</td> <td>hincrby user  age 10</td></tr> <tr><td>hlen key</td> <td>查看key对应的hash列表field的数量</td> <td>hlen user</td></tr> <tr><td>hkeys  key</td> <td>获取key对应的hash列表所有的field值</td> <td>hkeys  user</td></tr> <tr><td>hvals  key</td> <td>获取key对应的hash列表所有的field对应的value值</td> <td>kvals  user</td></tr> <tr><td>hgetall key</td> <td>获取key对应的hash列表中所有的field及其对应的value值</td> <td>hgetall user</td></tr></tbody></table> <h5 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h5> <p>Hash结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。</p> <p><strong>共享session设计</strong></p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
 <span class="token keyword">private</span> <span class="token class-name">String</span> userame<span class="token punctuation">;</span>
 <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>
 <span class="token keyword">private</span>  <span class="token class-name"><span class="token keyword">int</span></span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>登录用户：</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;dafei&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;666&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>登录缓存：</p> <p>key：<strong>user_token</strong>                value：<strong>new User(&quot;dafei&quot;, &quot;666&quot;, 18)</strong></p> <p>----------------------------------------------------------------------------------------------</p> <p>方案1： 将user对象转换json格式字符串存redis  【侧重于查， 改非常麻烦】</p> <p>key                            value</p> <p>---------------------------------------------------------------------------------------------</p> <p><strong>user_token</strong>   ：   <strong>&quot;{name:dafei, age:18, password:666}&quot;</strong></p> <p>方案2： 将user对象转换hash对象存redis【侧重于改，查询相对麻烦】</p> <p>key                            value</p> <p>---------------------------------------------------------------------------------------------</p> <p><strong>user_token</strong>   ：  <strong>{</strong></p> <p>​                                    <strong>name：ddafei</strong></p> <p>​                                    <strong>age ：    18</strong></p> <p>​                                    <strong>password： 666</strong></p> <p>​                                 <strong>}</strong></p> <h4 id="list类型"><a href="#list类型" class="header-anchor">#</a> List类型</h4> <p>Redis中的List类似C#中的Queue,也可以当做List来用.</p> <p>List类型是一个链表结构的集合，其主要功能有push、pop、获取元素等，更详细的说,List类型是一个双端链表的结构，我们可以通过相关操作进行集合的头部或者尾部添加删除元素，List的设计非常简单精巧，即可以作为栈,又可以作为队列，满足绝大多数需求.</p> <p>类似Java中：<strong>Map&lt;String, List&gt;  map</strong></p> <h5 id="常用的命令-3"><a href="#常用的命令-3" class="header-anchor">#</a> <strong>常用的命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>rpush  key  value</td> <td>从右边往key集合中添加value值</td> <td>rpush hobby java</td></tr> <tr><td>lrange key start stop</td> <td>从左边开始列表key集合，从start位置开始，stop位置结束</td> <td>lrange hobby 0 -1</td></tr> <tr><td>lpush key value</td> <td>从左边往key集合中添加value值</td> <td>lpush hobby c++</td></tr> <tr><td>lpop key</td> <td>弹出key集合中最左边的数据</td> <td>lpop hobby</td></tr> <tr><td>rpop key</td> <td>弹出key集合中最右边的数据</td> <td>rpop hobby</td></tr> <tr><td>llen key</td> <td>获取列表长度</td> <td>llen hooby</td></tr></tbody></table> <h5 id="非常用命令-2"><a href="#非常用命令-2" class="header-anchor">#</a> <strong>非常用命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>linsert key before pivot value</td> <td>操作key集合，在pivot值之前插入value</td> <td>linsert hobby before java  c#</td></tr> <tr><td>linsert key  after  pivot value</td> <td>操作key集合，在pivot值之后插入value</td> <td>linsert hobby after  java  c#</td></tr> <tr><td>lset key  index  value</td> <td>操作key集合，更新索引index位置值为value</td> <td>lset hobby 1  go</td></tr> <tr><td>lrem key count  value</td> <td>操作key集合，删除 count个 value值</td> <td>lrem hobby 3   go</td></tr> <tr><td>ltrim   key  start stop</td> <td>操作key集合，从start到stop截取自列表</td> <td>ltrim  hobby 2   4</td></tr> <tr><td>lindex  key  index</td> <td>操作key集合，获取索引为index位置的数据</td> <td>lindex  hobby 1</td></tr></tbody></table> <h5 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h5> <p>1&gt;用户收藏文章列表：</p> <p>key：user_favor_article_list</p> <p>value: [aid1, aid2, aid3......]</p> <h4 id="set类型"><a href="#set类型" class="header-anchor">#</a> Set类型</h4> <p>Set集合是String类型的无序集合,set是通过HashTable实现的，对集合我们可以取**交集、并集、差集。</p> <h5 id="常用的命令-4"><a href="#常用的命令-4" class="header-anchor">#</a> <strong>常用的命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>sadd key  members [....]</td> <td>往key 集合中添加member元素</td> <td>sadd myset a  b  c</td></tr> <tr><td>smembers key</td> <td>遍历key集合中所有的元素</td> <td>smembers myset</td></tr> <tr><td>srem  key members [....]</td> <td>删除key集合中members元素</td> <td>srem myset a</td></tr> <tr><td>spop key count</td> <td>从key集合中随机弹出count个元素</td> <td>spop myset 1</td></tr></tbody></table> <h5 id="非常用命令-3"><a href="#非常用命令-3" class="header-anchor">#</a> <strong>非常用命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td><strong>sdiff key1   key2</strong></td> <td><strong>返回key1中特有的元素(差集)</strong></td> <td><strong>sdiff key1 key2</strong></td></tr> <tr><td>sidiffstore  dest  key1 key2</td> <td>返回key1中特有的元素，并将返回值缓存到dest集合中</td> <td>sidiffstore  dest  key1 key2</td></tr> <tr><td><strong>sinter key1 key2</strong></td> <td><strong>返回key1跟key2集合的交集</strong></td> <td><strong>sinter key1 key2</strong></td></tr> <tr><td>sinterstore  dest key1 key2</td> <td>返回key1跟key2集合的交集，并将返回值缓存到dest集合中</td> <td>sinterstore  dest key1 key2</td></tr> <tr><td><strong>sunion key1  key2</strong></td> <td><strong>返回key1跟key2集合的并集</strong></td> <td><strong>sunion key1  key2</strong></td></tr> <tr><td>sunionstore dest key1  key2</td> <td>返回key1跟key2集合的并集，并将返回值缓存到dest集合中</td> <td>sunionstore dest key1  key2</td></tr> <tr><td>smove source destination member</td> <td>将source集合中member元素移动到destination集合中</td> <td>smove key1  key2 aa</td></tr> <tr><td>sismember key member</td> <td>判断member元素是否在key集合中</td> <td>sismember key1   aa</td></tr> <tr><td>srandmember  key  count</td> <td>随机获取set集合中count 个元素</td> <td>srandmember key1 1</td></tr></tbody></table> <h5 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h5> <p>1，去重；</p> <p>2，抽奖;</p> <p>​           1：准备一个抽奖池:sadd luckydraw 1 2 3 4 5 6 7 8 9 10 11 12 13</p> <p>​           2：抽3个三等奖:spop luckydraw 3</p> <p>​           3：抽2个二等奖:spop luckydraw 2</p> <p>​     4：抽1个:一等奖:spop luckydraw 1</p> <h4 id="sorted-set-类型"><a href="#sorted-set-类型" class="header-anchor">#</a> Sorted set 类型</h4> <p>Sorted set 也称Zset类型，是一种具有排序效果的set集合。它跟set集合一样也是 string 类型元素的集合，且不允许重复的成员。并且要求每个元素都会关联一个double 类型的分数。后续可以通过分数来为集合中的成员进行从小到大的排序。</p> <p>Sorted set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p> <p>数据缓存结构：</p> <h5 id="常用的命令-5"><a href="#常用的命令-5" class="header-anchor">#</a> <strong>常用的命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>zadd key score member</td> <td>往key集合中添加member元素，分数为score</td> <td>zadd players 100  a</td></tr> <tr><td>zincrby  key increment  member</td> <td>将key集合中的member元素 分数 + increment</td> <td>zadd players 100  a</td></tr> <tr><td>zrange  key  start  stop [withscores]</td> <td>将key集合中的元素按分数升序排列 [显式分数]</td> <td>zrange players 0 -1  withscores</td></tr> <tr><td>zrevrange key  start  stop [withscores]</td> <td>将key集合中的元素按分数降序排列 [显式分数]</td> <td>zrevrange players 0 -1  withscores</td></tr> <tr><td>zrank  key  member</td> <td>返回member元素在key结合中的正序排名</td> <td>zrank players  a</td></tr> <tr><td>zrevrank key  member</td> <td>返回member元素在key结合中的倒序排名</td> <td>zrevrank players  a</td></tr> <tr><td>zcard  key</td> <td>返回key集合元素个数</td> <td>zcard  players</td></tr></tbody></table> <h5 id="非常用命令-4"><a href="#非常用命令-4" class="header-anchor">#</a> <strong>非常用命令</strong></h5> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>zrangebyscore  key  min  max  [withscores]</td> <td>按[min, max) 分数范围返回key集合中元素(正序)</td> <td>zrangebyscore players  200 300  withscores</td></tr> <tr><td>zrevrangebyscore key  min  max  [withscores]</td> <td>按[min, max) 分数范围返回key集合中元素(倒序)</td> <td>zrevrangebyscore players  200 300  withscores</td></tr> <tr><td>zrem key member</td> <td>删除key集合中member元素与分数</td> <td>zrem players  a</td></tr> <tr><td>zremrangebyscore  key min max  withscores</td> <td>按[min, max) 分数范围删除key集合中元素</td> <td>zremrangebyscore  players  200 300  withscores</td></tr> <tr><td>zremrangebyrank  key start  stop</td> <td>删除key集合正序排名落在[start, stop) 范围元素</td> <td>zremrangebyrank  players  10  20</td></tr> <tr><td>zcount key min max</td> <td>按照分数范围[min, max]统计key集合中元素个数</td> <td>zcount  players  100 300</td></tr></tbody></table> <h5 id="应用场景-5"><a href="#应用场景-5" class="header-anchor">#</a> 应用场景</h5> <p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p> <h4 id="类型总结"><a href="#类型总结" class="header-anchor">#</a> 类型总结</h4> <p>一个问题，Redis在项目中如何使用？</p> <p>思考点：</p> <p>1&gt;项目是否需要使用到缓存？使用</p> <p>2&gt;使用缓存是否选用Redis？选用</p> <p>3&gt;使用Redis那该怎么设计Key-Value值？</p> <h5 id="value设计"><a href="#value设计" class="header-anchor">#</a> Value设计</h5> <p>先说value值的设计其实就是value类型选用： String， Hash， List， Set， Sort Set</p> <p>一般考虑：</p> <ul><li>是否需要排序？要使用Sort Set</li> <li>缓存的数据是多个值还是单个值，</li> <li>多个值：允许重复选List  不允许重复选择Set</li> <li>单个值：简单值选择String， 对象值选择Hash</li></ul> <p>操作方式：</p> <p>所有value之后都转换成json格式字符串，然后缓存到Redis，原因：操作方便，减少泛型操作麻烦</p> <p>不管存放啥数据类型，从reds中获取出来都是Object类型，后续对象强制转换麻烦，干脆直接使用字符串。</p> <h5 id="key设计"><a href="#key设计" class="header-anchor">#</a> Key设计</h5> <p>Redis 的key 设计讲究4个性：</p> <h6 id="唯一性"><a href="#唯一性" class="header-anchor">#</a> <strong>唯一性</strong></h6> <p>Redis 类似Map集合，key必须保证唯一，缓存同一个key时，后者会覆盖前者，所有必须要求唯一，那如何保证唯一呢？</p> <p>最常用的方式：<strong>使用缓存数据的主键作为key</strong>。</p> <p>比如：缓存员工信息</p> <p>key                             value</p> <p>----------------------------------------------------------------</p> <p>1                 员工1</p> <p>2                 员工2</p> <p>其中的1， 2 是员工的id</p> <h6 id="可读性"><a href="#可读性" class="header-anchor">#</a> <strong>可读性</strong></h6> <p>可读性是保证Redis的key能做到见名知意，上面的员工id1， 员工id2 虽说能保证key唯一，但可读性非常差，维护key时，无法从， 1， 2中快速判断该key对应value值。所以一一般在保证key唯一的前提下，给key加上前缀：</p> <p>key                                       value</p> <p>----------------------------------------------------------------</p> <p>employee_info:id1            员工1</p> <p>employee_info:id2            员工2</p> <p>employee_info:id1     employee_info:id2  这样子设计key，可读性就好多了。</p> <p>可读性前缀的设计规范千奇百怪，我个人比较推崇的：</p> <ul><li><p>普通单值</p> <p>key                                       value</p> <p>----------------------------------------------------------------</p> <p>employe_info:id1              员工对象信息</p></li> <li><p>类似关系型数据库设计</p> <p><strong>表名:主键名:主键值:列名</strong></p> <p>key                                       value</p> <p>----------------------------------------------------------------</p> <p>employee : id : 1:info        员工对象信息</p></li> <li><p>通用玩法</p> <p><strong>业务模块名:业务逻辑含义:其他:value类型</strong></p> <p>key                                                        value</p> <p>-----------------------------------------------------------------------</p> <p>employee :base.info:id1:hash         员工对象信息</p> <p><strong>业务模块名</strong>：表示该key属于哪个功能模块</p> <p><strong>业务逻辑含义段</strong>：这里可以使用  <strong>.</strong>  分开， 具体业务逻辑表示</p> <p>​ 比如：缓存员工权限</p> <p>​    employee:auth.permission:id1:set     员工权限集合</p> <p><strong>其他</strong>：一般设置唯一标识，比如主键</p> <p><strong>value类型</strong>：key对应value类型值，提高可读性。</p></li></ul> <h3 id="redis全局命令"><a href="#redis全局命令" class="header-anchor">#</a> Redis全局命令</h3> <p>全局命令针对的是所有的key，大部分用来做运维，做管理的</p> <p>常用的全局key</p> <table><thead><tr><th>命令格式</th> <th>功能</th> <th>案例</th></tr></thead> <tbody><tr><td>keys  pattern</td> <td>按照pattern 匹配规则，列表redis中所有的key</td> <td>keys xxx:*</td></tr> <tr><td>exists  key</td> <td>判断key是否存在</td> <td>exists name</td></tr> <tr><td>expire key  seconds</td> <td>给key设置过期时间，超时：seconds</td> <td>expire name 10</td></tr> <tr><td>persist key</td> <td>取消key过期时间</td> <td>persist  name</td></tr> <tr><td>select  index</td> <td>切换数据库，默认是第0个，共有【0,15】个</td> <td>select 0</td></tr> <tr><td>move key   db</td> <td>从当前数据库将key移动到指定db库</td> <td>move name 1</td></tr> <tr><td>randomkey</td> <td>随机返回一个key</td> <td>randomkey</td></tr> <tr><td>rename key newkey</td> <td>将key改名为newkey</td> <td>rename name  newname</td></tr> <tr><td>echo message</td> <td>打印message信息</td> <td>echo  message</td></tr> <tr><td>dbsize</td> <td>查看key个数</td> <td>dbsize</td></tr> <tr><td>info</td> <td>查看redis数据库信息</td> <td>info</td></tr> <tr><td>config get  *</td> <td>查看所有redis配置信息</td> <td>config get *</td></tr> <tr><td>flushdb</td> <td>清空当前数据库</td> <td>flushdb</td></tr> <tr><td>flushall</td> <td>清空所有数据库</td> <td>flushall</td></tr></tbody></table> <h3 id="redis安全性"><a href="#redis安全性" class="header-anchor">#</a> Redis安全性</h3> <p>因为Redis速度非常快，所以在一台比较好的服务器下,一个外部用户在一秒内可以进行15w次的密码尝试，这意味你需要设定非常强大的密码来方式暴力破解。此时就需要对Redis进行密码设置啦。</p> <p><strong>Linux系统</strong></p> <p>编辑 redis.conf文件，找到下面进行保存修改
<strong>requirepass 自定义密码</strong></p> <p>重启Redis服务，访问时，使用带密码的命令：</p> <p><strong>redis-cli -a 自定义密码</strong></p> <p>否则会提示： (error)NOAUTH Authentication required.</p> <p>Window系统</p> <p>跟Linux系统一样，区别是，window系统的文件是</p> <p><strong>redis.window-service.config</strong></p> <h3 id="redis的作用-重点理解"><a href="#redis的作用-重点理解" class="header-anchor">#</a> <strong>Redis的作用[重点理解]</strong></h3> <p>1.缓存：作为内存数据库，Redis 可以用作缓存层来提高读取频繁的数据访问性能。将经常访问的数据存储在 Redis 中，可以避免频繁地从磁盘或数据库中读取数据，提高系统的响应速度。</p> <p>2.分布式锁：Redis 提供了原子性操作和分布式特性，可以利用这些特性实现分布式锁。通过 Redis 的 SETNX（SET if Not eXists）命令或 RedLock 算法等机制，可以实现多个进程或服务器之间的协调和互斥，确保共享资源的一致性和安全性。</p> <p>3.队列和消息代理：Redis 的列表（List）数据结构可以用作队列的实现，通过将任务或消息放入列表，消费者可以按照顺序获取并处理队列中的元素。此外，Redis 的发布-订阅（Pub/Sub）功能也可以用作简单的消息代理，用于消息的发布和订阅、事件驱动等场景。</p> <p>4.计数器和统计：Redis 支持原子递增（INCR）和递减（DECR）操作，可以用来实现计数器功能，例如网站的文章浏览量统计、用户点赞数等。</p> <p>5.分布式会话存储：将会话（Session）数据存储在 Redis 中，实现多个应用服务器之间的会话共享，可以提高系统的可扩展性和灵活性。</p> <h3 id="redis事务-拓展"><a href="#redis事务-拓展" class="header-anchor">#</a> Redis事务[拓展]</h3> <p>一个事务从开始到执行会经历以下三个阶段：</p> <ul><li>开始事务。</li> <li>命令入队。</li> <li>执行事务。</li></ul> <p>借用：菜鸟教程中例子</p> <p>它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> MULTI
OK

redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SET book-name <span class="token string">&quot;Mastering C++ in 21 days&quot;</span>
QUEUED

redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> GET book-name
QUEUED

redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SADD tag <span class="token string">&quot;C++&quot;</span> <span class="token string">&quot;Programming&quot;</span> <span class="token string">&quot;Mastering Series&quot;</span>
QUEUED

redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SMEMBERS tag
QUEUED

redis <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> EXEC
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Mastering C++ in 21 days&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Mastering Series&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;C++&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Programming&quot;</span>
</code></pre></div><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p> <p>Redis事务可以理解为一个<strong>打包的批量执行脚本</strong>，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multi
OK
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> name dafei
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> age <span class="token number">18</span>
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> incr age 
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> incr name
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> get age
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> get name
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span>
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> OK
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">19</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer or out of range
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;19&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;dafei&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> 
</code></pre></div><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p> <ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li> <li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li> <li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul> <h3 id="redis持久化机制-拓展"><a href="#redis持久化机制-拓展" class="header-anchor">#</a> Redis持久化机制[拓展]</h3> <h4 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h4> <p>先来一个小实验，大家可以一起实现一下</p> <p>步骤1：在Redis中添加2个key-value对</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> aa aa
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> bb bb
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *
</code></pre></div><p>步骤2：重启Redis 服务器，在执行keys * 观察数据</p> <p>步骤3：分析结果</p> <p>会出现一下几种结果：</p> <ul><li>之前的key在，aa  bb 都在（最理想的结果）</li> <li>之前的key在，aa也在，bb不见了</li> <li>之前的key在，aa， bb 不在</li> <li>之前的key， aa， bb 都不在了（最坏的结果）</li></ul> <p>思考：</p> <p>为啥会这样？以我们对内存的操作理解，按道理重启之后数据应该全丢失了，为啥Redis 可能丢失，也可能不丢失，为何？</p> <p>这里就涉及到Redis的持久化机制了。</p> <p>Redis持久化机制目前以后3种，分别为：</p> <p>1&gt;<strong>快照方式</strong>（RDB, Redis DataBase）</p> <p>2&gt;<strong>文件追加方式</strong>（AOF, Append Only File）</p> <p>3&gt;<strong>混合持久化方式</strong>（Redis4版本之后）</p> <h4 id="rdb方式"><a href="#rdb方式" class="header-anchor">#</a> RDB方式</h4> <p>Snapshotting(快照)默认方式，将内存数据中以快照的方式写入到二进制文件中，默认为dump.rdb。触发RDB持久化过程分手动触发与自动触发。</p> <h5 id="触发机制"><a href="#触发机制" class="header-anchor">#</a> 触发机制</h5> <p><strong>手动触发</strong></p> <p>使用save命令：会阻塞当前Redis服务器，知道RDB过程完成为主，如果内存数据较多，会造成长时间阻塞，影响其他命令的使用，不建议轻易使用</p> <p>使用bgsave命令：Redis进程执行fork指令创建子进程，由子进程实现RDB持久化，有需要时建议使用bgsave命令。</p> <p><strong>自动触发</strong></p> <p>使用save相关配置，格式： save m n      表示m秒内数据集存在n次修改时会自动触发bgsave命令。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">save</span> <span class="token number">900</span> <span class="token number">1</span>  <span class="token comment">#900秒内如果超过1个Key被修改则发起快照保存</span>
<span class="token keyword">save</span> <span class="token number">300</span> <span class="token number">10</span> <span class="token comment">#300秒内如果超过10个key被修改,则发起快照保存</span>
<span class="token keyword">save</span> <span class="token number">60</span> <span class="token number">10000</span>
</code></pre></div><h5 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h5> <ul><li><p>RDB快照文件是一个紧凑压缩的二进制文件，非常使用用于备份，全量复制等场景。开发中可以按照每6小时执行一次bgsave备份，用于容灾备份。</p></li> <li><p>Redis加载RDB恢复数据远远快于AOF方式</p></li></ul> <h5 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h5> <ul><li>RDB无法做到实时持久化/秒级持久化，每次bgsave时都需要fork子进程，频繁执行有时间成本。</li> <li>RDB快照文件不同版本格式不一样，容易引起兼容问题。</li></ul> <h4 id="aof方式"><a href="#aof方式" class="header-anchor">#</a> AOF方式</h4> <p>AOF与RDB不一样，它是一独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。解决了数据持久化的实时性的问题。</p> <p>Redis默认是不开启的，需要使用时，需要配置： <strong>appendonly yes</strong></p> <p>AOF 有3种文件同步策略</p> <table><thead><tr><th>策略</th> <th>解释</th></tr></thead> <tbody><tr><td>appendfsync always</td> <td>收到命令就立即写到磁盘,效率最慢.但是能保证完全的持久化</td></tr> <tr><td>appendfsync everysec</td> <td>每秒写入磁盘一次,在性能和持久化方面做了很好的折中</td></tr> <tr><td>appendfsync no</td> <td>完全以依赖os，一般同步周期是30秒</td></tr></tbody></table> <h5 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h5> <ul><li><p>AOF方式数据安全性更高，配置得当，最多损失1秒的数据量</p></li> <li><p>在不小心执行flushall命令，也可以通过AOF方式恢复(删除最后一个命令即可)</p></li> <li><p>AOF 日志是一个增量日志文件，不会存在断电时出现损坏问题。即使出现问题，redis-check-aof 工具也能够轻松修复它。</p></li> <li><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF</p></li></ul> <h5 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h5> <ul><li>相同数据量来说，AOF文件体积通常大于RDB文件</li> <li>数据持久化性能上来说，AOF 比 RDB 慢</li></ul> <h4 id="rdb-aof混合方式"><a href="#rdb-aof混合方式" class="header-anchor">#</a> RDB-AOF混合方式</h4> <p>混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件。即以 RDB 作为全量备份，AOF 作为增量备份，来提高备份效率。这样既能保证 Redis 重启时的速度，又能防止数据丢失的风险， 这就是 Redis 4.0 之后推出的 <strong>RDB-AOF 混合持久化模式，其作为默认配置来使用</strong>。</p> <h4 id="持久化机制选择"><a href="#持久化机制选择" class="header-anchor">#</a> 持久化机制选择</h4> <ul><li><p>如果对数据安全性有非常高的要求，建议 RDB 和 AOF 同时启用。</p></li> <li><p>如果对数据安全性要求不是很高，能够容忍数据的丢失，建议单独使用 RDB。</p></li> <li><p>不推荐单独使用 AOF，因为对于进行数据库备份、更快重启以及 AOF 引擎中出现错误的情况来说，RDB 是更好的选择。</p></li> <li><p>如果没特殊要求，Redis又是4.x版本以上，可以选择RDB-AOF混合方式。</p></li></ul> <p>如果不是混合模式，而是普通的RDB与AOF一起启动时，Redis加载数据执行流程</p> <h3 id="redis内存淘汰机制-拓展"><a href="#redis内存淘汰机制-拓展" class="header-anchor">#</a> Redis内存淘汰机制[拓展]</h3> <h4 id="引言-2"><a href="#引言-2" class="header-anchor">#</a> 引言</h4> <p>Redis 启动会加载一个配置：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>maxmemory <span class="token operator">&lt;</span>byte<span class="token operator">&gt;</span>   //内存上限
</code></pre></div><p>默认值为 0 (window版的限制为100M)，表示默认设置Redis内存上限。但是真实开发还是需要提前评估key的体量，提前设置好内容上限。</p> <p>此时思考一个问题，开发中，在设置完内存上限之后，如果Redis key达到上限了，该怎么办？这就设置到Redis的内存淘汰机制了。</p> <h4 id="内存淘汰算法"><a href="#内存淘汰算法" class="header-anchor">#</a> 内存淘汰算法</h4> <p>Redis内存淘汰机制也可以称之为key内卷机制，当资源不足时，该如何选择？</p> <p>常见的内存淘汰机制分为四大类：</p> <ul><li><p>**LRU：**LRU是Least recently used，最近最少使用的意思，简单的理解就是从数据库中删除最近最少访问的数据，该算法认为，你长期不用的数据，那么被再次访问的概率也就很小了，淘汰的数据为最长时间没有被使用，仅与时间相关。</p></li> <li><p>**LFU：**LFU是Least Frequently Used，最不经常使用的意思，简单的理解就是淘汰一段时间内，使用次数最少的数据，这个与频次和时间相关。</p></li> <li><p>**TTL：**Redis中，有的数据是设置了过期时间的，而设置了过期时间的这部分数据，就是该算法要解决的对象。如果你快过期了，不好意思，我内存现在不够了，反正你也要退休了，提前送你一程，把你干掉吧。</p></li> <li><p>随机淘汰：生死有命，富贵在天。</p></li></ul> <h3 id="过期key处理-拓展"><a href="#过期key处理-拓展" class="header-anchor">#</a> 过期Key处理[拓展]</h3> <p>接下讨论一个问题：Redis的key过期了，该如何清理问题。</p> <p>Redis给出3种实现方案：</p> <p><strong>惰性删除</strong>：当访问Key时，才去判断它是否过期，如果过期，直接干掉。这种方式对CPU很友好，但是一个key如果长期不用，一直存在内存里，会造成内存浪费。</p> <p><strong>定时删除</strong>：设置键的过期时间的同时，创建一个定时器，当到达过期时间点，立即执行对Key的删除操作，这种方式对CPU不友好，得额外让出CPU维护定时器。</p> <p><strong>定期删除</strong>：隔一段时间，对数据进行一次检查，删除里面的过期Key，至于要删除多少过期Key，检查多少数据，则由算法决定。</p> <p><strong>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，可以很好地在合理使用CPU和避免浪费内存之间取得平衡。</strong></p> <h3 id="redis编程"><a href="#redis编程" class="header-anchor">#</a> Redis编程</h3> <p>实战练习</p> <p>案例一：</p> <p>1.将选手全表数据存入Reids中</p> <p>难点：1）使用什么数据类型</p> <p>​   2）当用户搜索时，如何处理？</p> <p>2.编写投票接口，当投票成功后，在Redis中记录票数</p> <p>3.编写一个实时的排行榜接口，当调用接口时，返回当前选手投票的排行。</p> <p>案例二：</p> <p>分布式服务器集群下，共享Session的设计实现。</p> <p>案例三：</p> <p>实现一个消息队列，一个生产端，一个消费端。</p> <h3 id="demo"><a href="#demo" class="header-anchor">#</a> Demo</h3> <p>使用StackExchange.Redis生成100W的订单，然后用多个程序读取处理。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListLeftPush：从左侧添加<span class="token punctuation">,</span>返回集合总数
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListRightPush：从右侧添加，返回集合总数
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListLeftPop：从左侧取<span class="token number">1</span>个值，并删除
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListRightPop：从右侧取<span class="token number">1</span>个值<span class="token punctuation">,</span>并删除
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListInsertBefore：指定的key指定<span class="token keyword">value</span>之前<span class="token punctuation">(</span>左边<span class="token punctuation">)</span>插入<span class="token number">1</span>个值
<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListInsertAfter：指定的key指定<span class="token keyword">value</span>之后<span class="token punctuation">(</span>右边<span class="token punctuation">)</span>插入<span class="token number">1</span>个值
<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListGetByIndex：获取key的指定索引对应的<span class="token keyword">value</span>值<span class="token punctuation">(</span>从左往右算<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListRange：获取key的所有<span class="token keyword">value</span>，数据类型得一致 （也可以获取指定索引之间的<span class="token keyword">value</span>值，带扩展）
<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListLength：获取指定key的数据的个数
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListRemove：删除指定key对应的指定<span class="token keyword">value</span>值，返回删除的个数
<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span> ListRightPopLeftPush：从List1右侧取一个值加到List2左侧<span class="token punctuation">,</span>返回的是右侧取出来的这个值
</code></pre></div><p>订单生成：GenerateList.cs</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">StackExchange<span class="token punctuation">.</span>Redis</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Diagnostics</span><span class="token punctuation">;</span>

<span class="token class-name">ConnectionMultiplexer</span> client <span class="token operator">=</span> ConnectionMultiplexer<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.239.128:6379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> db <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">GetDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//List 叫NumberList 然后往消息队列中放置10W个订单</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;订单生成中。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 计时器</span>
<span class="token class-name">Stopwatch</span> stopwatch <span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Stopwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动计时器</span>
stopwatch<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    db<span class="token punctuation">.</span><span class="token function">ListRightPush</span><span class="token punctuation">(</span><span class="token string">&quot;NumberList&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;order&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 停止计时器</span>
stopwatch<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取经过的时间</span>
<span class="token class-name">TimeSpan</span> elapsedTime <span class="token operator">=</span> stopwatch<span class="token punctuation">.</span>Elapsed<span class="token punctuation">;</span>
<span class="token comment">// 输出秒和毫秒</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;程序运行时间: {0} 秒 {1} 毫秒&quot;</span><span class="token punctuation">,</span>elapsedTime<span class="token punctuation">.</span>Seconds<span class="token punctuation">,</span> elapsedTime<span class="token punctuation">.</span>Milliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>订单处理：GetList.cs</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">StackExchange<span class="token punctuation">.</span>Redis</span><span class="token punctuation">;</span>

<span class="token class-name">ConnectionMultiplexer</span> client <span class="token operator">=</span> ConnectionMultiplexer<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.239.128:6379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> db <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">GetDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> order <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">ListLeftPop</span><span class="token punctuation">(</span><span class="token string">&quot;NumberList&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;procee1_正在处理：&quot;</span> <span class="token operator">+</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>db<span class="token punctuation">.</span><span class="token function">ListLength</span><span class="token punctuation">(</span><span class="token string">&quot;NumberList&quot;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;订单处理完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/后端.html" class="prev">
        CSharp
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3e89323d.js" defer></script><script src="/assets/js/2.733019b2.js" defer></script><script src="/assets/js/11.136159a4.js" defer></script>
  </body>
</html>
